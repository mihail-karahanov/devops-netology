# Домашнее задание к занятию "6.6. Troubleshooting" - Михаил Караханов

## Задача 1

>Перед выполнением задания ознакомьтесь с документацией по [администрированию MongoDB](https://docs.mongodb.com/manual/administration/).
>
>Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её нужно прервать.
>
>Вы как инженер поддержки решили произвести данную операцию:
>
>- напишите список операций, которые вы будете производить для остановки запроса пользователя
>- предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB

**Ответ:**

- Для поиска выполняющейся в данный момент времени CRUD операции можно воспользоваться командой встроенной оболочки MongoDB - `db.currentOp()`. Для точного поиска, можно запросить у разработчика описание запроса и передать указанной команде как аргумент (filter). В случае успешного завершения команды, из её вывода получим ID операции - `opid` для последующих действий. Для корректного завершения "зависшей" операции, необходимо выполнить команду `db.killOp(<opid>)`, аргументом для которой будет полученный ранее ID операции.
- Для установки ограничения на время исполнения операций можно воспользоваться методом `maxTimeMS()`. Данный метод может применяться для каждой операции, лимит на исполнение операции передается как аргумент в скобках (значение лимита указывается в миллисекундах). При достижении временного лимита на исполнение операции, система MongoDB автоматически завершит данную операцию.

## Задача 2

>Перед выполнением задания познакомьтесь с документацией по [Redis latency troobleshooting](https://redis.io/topics/latency).
>
>Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная и увеличивается пропорционально количеству реплик сервиса.
>
>При масштабировании сервиса до N реплик вы увидели, что:
>
>- сначала рост отношения записанных значений к истекшим
>- Redis блокирует операции записи
>
>Как вы думаете, в чем может быть проблема?

**Ответ**:

Проблема, скорее всего, во внутреннем активном механизме очистки устаревших ключей Redis. Механизм очистки запускается каждые 100 миллисекунд (10 раз в секунду). Если после одной итерации устаревших ключей остается более 25% от общего числа, очистка запускается снова.

При масштабировании сервиса, увеличивается общее количество ключей в системе, но также и увеличиваются темпы прироста устаревших ключей. Внутренний механизм очистки устаревших ключей Redis, в случае, если в течении каждой 1 секунды количество устаревших ключей равно или становится больше 25% от общего количества, может заблокировать запись в базу до понижения количества устаревших ключей ниже 25% от всего объема.

## Задача 3

>Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы, пользователи начали жаловаться на ошибки вида:
>
>```python
>InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
>```
>
>Как вы думаете, почему это начало происходить и как локализовать проблему?
>
>Какие пути решения данной проблемы вы можете предложить?

**Ответ:**

Поиск описания данной ошибки в базе знаний MySQL привел к выводу, что данная ошибка свидетельствует о закрытии сетевой сессии к БД по таймауту. При росте количества передаваемых/считываемых строк из БД при удаленном подключении, операция прерывается по таймауту, заданному в конфигурации MySQL. За это отвечает параметр конфигурации `net_read_timeout`, по умолчанию установленный на 30 секунд. Для решения указанной проблемы можно увеличить его значение на время, достаточное для завершения передачи информации по сети.

## Задача 4

>Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с большим объемом данных лучше, чем MySQL.
>
>После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:
>
>`postmaster invoked oom-killer`
>
>Как вы думаете, что происходит?
>
>Как бы вы решили данную проблему?

**Ответ:**

Данное сообщение свидетельствует о том, что ядро ОС запустило процесс `Out-of-Memory Killer` из-за нехватки физической оперативной памяти и swap. Причиной является то, что процесс `postmaster` или другой процесс в системе запросил объем требуемой памяти больший, чем доступен в данный момент времени. Если запуск процесса OOM Killer вызван самим PostgreSQL, то можно выполнить следующие действия, описанные в [официальной документации](https://www.postgresql.org/docs/14/kernel-resources.html#LINUX-MEMORY-OVERCOMMIT), для оперативного решения проблемы:

- если увеличение объема физической памяти невозможно в данный момент, можно увеличить объем swap
- необходимо скорректировать значения параметров конфигурации, отвечающих за потребление системной памяти, в первую очередь `shared_buffers`, `work_mem` и `hash_mem_multiplier`
